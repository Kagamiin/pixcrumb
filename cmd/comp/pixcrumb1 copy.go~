package comp

import (
	"fmt"

	"github.com/Kagamiin/pixcrumb/cmd/imgtools"
)

const (
	pc1Name       = "pixcrumb-rle"
	pc1AbbrevName = "pc1"
)

type PixCrumb1Blob struct {
	heightFragments uint8
	widthTiles      uint8
	rleStream       *[]byte
	dataStream      *[]byte
}

var _ PixCrumbBlob = &PixCrumb1Blob{}

func (b *PixCrumb1Blob) GetTotalSize() uint64 {
	return uint64(len(*b.rleStream) + len(*b.dataStream) + 4)
}

type pixCrumb1State struct {
	blob                 PixCrumb1Blob
	rleEnc               BitstreamBE
	dataEnc              BitstreamBE
	rleMode              bool
	rleCount             uint16
	modeSwitches         uint64
	literalCrumbsWritten uint64
	rleCrumbsProcessed   uint64
}

var _ PixCrumbCodec = &pixCrumb1State{}

func NewPixCrumb1() PixCrumbEncoder {
	return &pixCrumb1State{}
}

func NewPixCrumb1Decoder(compressedData PixCrumb1Blob) PixCrumbDecoder {
	return &pixCrumb1State{
		blob: compressedData,
	}
}

func (s *pixCrumb1State) GetName() string {
	return pc1Name
}

func (s *pixCrumb1State) GetAbbrevName() string {
	return pc1AbbrevName
}

func (s *pixCrumb1State) Compress(crp *imgtools.CrumbPlane) (PixCrumbBlob, error) {
	wb := crp.GetWidthBpBytes()
	w := crp.GetWidthCrumbs()
	h := crp.GetHeightCrumbs()
	if wb > 255 || h > 255 {
		return nil, fmt.Errorf("%w: rounded pixel dimensions %dx%d exceed max dimensions of 2040x510", ErrImageTooLarge, wb*8, h*2)
	}
	rleBytes := make([]byte, 0)
	dataBytes := make([]byte, 0)
	s.blob = PixCrumb1Blob{
		heightFragments: uint8(h),
		widthTiles:      uint8(wb),
		rleStream:       &rleBytes,
		dataStream:      &dataBytes,
	}
	s.rleEnc.data = s.blob.rleStream
	s.dataEnc.data = s.blob.dataStream
	s.rleMode = false
	s.rleCount = 0
	s.rleEnc.Reset()
	s.dataEnc.Reset()
	s.modeSwitches = 0
	s.literalCrumbsWritten = 0
	s.rleCrumbsProcessed = 0

	rawData := crp.GetCrumbs()

	for i := uint64(0); i < h; i++ {
		if i&1 == 0 {
			for j := uint64(0); j < w; j++ {
				s.packCrumb(rawData[i][j])
			}
		} else {
			for j := int(w - 1); j >= 0; j-- {
				s.packCrumb(rawData[i][j])
			}
		}
	}

	fmt.Printf("encoding completed with %d modeswitches, %d literal crumbs written, %d rle crumbs processed, total %d crumbs\n", s.modeSwitches, s.literalCrumbsWritten, s.rleCrumbsProcessed, s.literalCrumbsWritten+s.rleCrumbsProcessed)

	return &s.blob, nil
}

func (s *pixCrumb1State) packCrumb(c imgtools.Crumb) {
	if s.rleMode {
		if c == 0 {
			s.rleCount++
			s.rleCrumbsProcessed++
		} else {
			s.rleEnc.WriteExpOrderKGolombNumber16(s.rleCount-1, 2)
			s.dataEnc.WriteBits(uint64(c), 4)
			s.literalCrumbsWritten++
			s.rleCount = 0
			s.rleMode = false
			s.modeSwitches++
		}
	} else {
		s.dataEnc.WriteBits(uint64(c), 4)
		if c == 0 {
			s.rleCrumbsProcessed++
			s.rleCount = 1
			s.rleMode = true
			s.modeSwitches++
		} else {
			s.literalCrumbsWritten++
		}
	}
}

func (s *pixCrumb1State) Decompress() (*imgtools.CrumbPlane, error) {
	panic("not implemented")
}
